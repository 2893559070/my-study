(window.webpackJsonp=window.webpackJsonp||[]).push([[114],{511:function(t,s,a){"use strict";a.r(s);var _=a(56),v=Object(_.a)({},(function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"面试"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#面试"}},[t._v("#")]),t._v(" 面试")]),t._v(" "),a("h2",{attrs:{id:"_1-http-和-https"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-http-和-https"}},[t._v("#")]),t._v(" 1. HTTP 和 HTTPS")]),t._v(" "),a("h3",{attrs:{id:"_1-1-http-和-https-的基本概念"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-http-和-https-的基本概念"}},[t._v("#")]),t._v(" 1.1 http 和 https 的基本概念")]),t._v(" "),a("ul",[a("li",[t._v("http: 是一个客户端和服务器端请求和应答的标准（TCP），用于从 WWW 服务器传输超文本到本地浏览器的超文本传输协议。")]),t._v(" "),a("li",[t._v("https:是以安全为目标的 HTTP 通道，即 HTTP 下 加入 SSL 层进行加密。其作用是：建立一个信息安全通道，来确保数据的传输，确保网站的真实性。")])]),t._v(" "),a("h3",{attrs:{id:"_1-2-http-和-https-的区别及优缺点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-http-和-https-的区别及优缺点"}},[t._v("#")]),t._v(" 1.2 http 和 https 的区别及优缺点？")]),t._v(" "),a("ul",[a("li",[t._v("http 是超文本传输协议，信息是明文传输，HTTPS 协议要比 http 协议安全，https 是具有安全性的 ssl 加密传输协议，可防止数据在传输过程中被窃取、改变，确保数据的完整性")]),t._v(" "),a("li",[t._v("http 协议的默认端口为 80，https 的默认端口为 443。")]),t._v(" "),a("li",[t._v("http 的连接很简单，是无状态的。https 握手阶段比较费时，会使页面加载时间延长 50%，增加 10%~20%的耗电。")]),t._v(" "),a("li",[t._v("https 缓存不如 http 高效，会增加数据开销。")]),t._v(" "),a("li",[t._v("Https 协议需要 ca 证书，费用较高，功能越强大的证书费用越高。")]),t._v(" "),a("li",[t._v("SSL 证书需要绑定 IP，不能再同一个 IP 上绑定多个域名，IPV4 资源支持不了这种消耗。")])]),t._v(" "),a("h3",{attrs:{id:"_1-3-https-协议的工作原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-3-https-协议的工作原理"}},[t._v("#")]),t._v(" 1.3 https 协议的工作原理")]),t._v(" "),a("p",[t._v("客户端在使用 HTTPS 方式与 Web 服务器通信时有以下几个步骤：")]),t._v(" "),a("ol",[a("li",[t._v("客户端使用 https url 访问服务器，则要求 web 服务器建立 ssl 链接。")]),t._v(" "),a("li",[t._v("web 服务器接收到客户端的请求之后，会将网站的证书（证书中包含了公钥），传输给客户端。")]),t._v(" "),a("li",[t._v("客户端和 web 服务器端开始协商 SSL 链接的安全等级，也就是加密等级。")]),t._v(" "),a("li",[t._v("客户端浏览器通过双方协商一致的安全等级，建立会话密钥，然后通过网站的公钥来加密会话密钥，并传送给网站。")]),t._v(" "),a("li",[t._v("web 服务器通过自己的私钥解密出会话密钥。")]),t._v(" "),a("li",[t._v("web 服务器通过会话密钥加密与客户端之间的通信。")])]),t._v(" "),a("p",[a("a",{attrs:{href:"https://juejin.cn/post/6995109407545622542",target:"_blank",rel:"noopener noreferrer"}},[t._v("解读 HTTP1/HTTP2/HTTP3"),a("OutboundLink")],1)]),t._v(" "),a("h2",{attrs:{id:"_2-tcp三次握手"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-tcp三次握手"}},[t._v("#")]),t._v(" 2. TCP三次握手")]),t._v(" "),a("ol",[a("li",[t._v("第一次握手：建立连接时，客户端发送syn包（syn=j）到服务器，并进入SYN_SENT状态，等待服务器确认；SYN：同步序列编号（Synchronize Sequence Numbers）。")]),t._v(" "),a("li",[t._v("第二次握手：服务器收到syn包并确认客户的SYN（ack=j+1），同时也发送一个自己的SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态。")]),t._v(" "),a("li",[t._v("第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。")])]),t._v(" "),a("h2",{attrs:{id:"_3-tcp-ip-如何保证数据包传输的有序可靠"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-tcp-ip-如何保证数据包传输的有序可靠"}},[t._v("#")]),t._v(" 3. TCP/IP / 如何保证数据包传输的有序可靠？")]),t._v(" "),a("p",[t._v("对字节流分段并进行编号然后通过 ACK 回复和超时重发这两个机制来保证。")]),t._v(" "),a("ol",[a("li",[t._v("为了保证数据包的可靠传递，发送方必须把已发送的数据包保留在缓冲区；")]),t._v(" "),a("li",[t._v("并为每个已发送的数据包启动一个超时定时器；")]),t._v(" "),a("li",[t._v("如在定时器超时之前收到了对方发来的应答信息（可能是对本包的应答，也可以是对本包后续包的应答），则释放该数据包占用的缓冲区;")]),t._v(" "),a("li",[t._v("否则，重传该数据包，直到收到应答或重传次数超过规定的最大次数为止。")]),t._v(" "),a("li",[t._v("接收方收到数据包后，先进行CRC校验，如果正确则把数据交给上层协议，然后给发送方发送一个累计应答包，表明该数据已收到，如果接收方正好也有数据要发给发送方，应答包也可方在数据包中捎带过去。")])]),t._v(" "),a("h2",{attrs:{id:"_4-tcp和udp的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-tcp和udp的区别"}},[t._v("#")]),t._v(" 4. TCP和UDP的区别")]),t._v(" "),a("ol",[a("li",[t._v("TCP是面向链接的，而UDP是面向无连接的。")]),t._v(" "),a("li",[t._v("TCP仅支持单播传输，UDP 提供了单播，多播，广播的功能。")]),t._v(" "),a("li",[t._v("TCP的三次握手保证了连接的可靠性; UDP是无连接的、不可靠的一种数据传输协议，首先不可靠性体现在无连接上，通信都不需要建立连接，对接收到的数据也不发送确认信号，发送端不知道数据是否会正确接收。")]),t._v(" "),a("li",[t._v("UDP的头部开销比TCP的更小，数据传输速率更高，实时性更好。")])]),t._v(" "),a("p",[a("a",{attrs:{href:"https://juejin.cn/post/6992743999756845087",target:"_blank",rel:"noopener noreferrer"}},[t._v("深度剖析TCP与UDP的区别"),a("OutboundLink")],1)]),t._v(" "),a("h2",{attrs:{id:"_5-http-请求跨域问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5-http-请求跨域问题"}},[t._v("#")]),t._v(" 5. HTTP 请求跨域问题")]),t._v(" "),a("ol",[a("li",[t._v("跨域的原理")])]),t._v(" "),a("ul",[a("li",[t._v("跨域，是指浏览器不能执行其他网站的脚本。它是由浏览器的同源策略造成的。")]),t._v(" "),a("li",[t._v("同源策略,是浏览器对 JavaScript 实施的安全限制，只要协议、域名、端口有任何一个不同，都被当作是不同的域。")]),t._v(" "),a("li",[t._v("跨域原理，即是通过各种方式，避开浏览器的安全限制。")])]),t._v(" "),a("ol",{attrs:{start:"2"}},[a("li",[t._v("解决方案")])]),t._v(" "),a("ul",[a("li",[a("p",[t._v("JSONP：\najax 请求受同源策略影响，不允许进行跨域请求，而 script 标签 src 属性中的链 接却可以访问跨域的 js 脚本，利用这个特性，服务端不再返回 JSON 格式的数据，而是 返回一段调用某个函数的 js 代码，在 src 中进行了调用，这样实现了跨域。缺点: JSON 只支持 get，因为 script 标签只能使用 get 请求； JSONP 需要后端配合返回指定格式的数据。")]),t._v(" "),a("p",[t._v("使用方式：")]),t._v(" "),a("ol",[a("li",[t._v("去创建一个script标签")]),t._v(" "),a("li",[t._v("script的src属性设置接口地址")]),t._v(" "),a("li",[t._v("接口参数，必须要带一个自定义函数名，要不然后台无法返回数据")]),t._v(" "),a("li",[t._v("通过定义函数名去接受返回的数据")])]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//动态创建 script")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" script "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" document"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("createElement")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'script'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 设置回调函数")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("getData")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("data")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    console"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("data"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//设置 script 的 src 属性，并设置请求地址")]),t._v("\nscript"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("src "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'http://localhost:3000/?callback=getData'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 让 script 生效")]),t._v("\ndocument"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("body"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("appendChild")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("script"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])])]),t._v(" "),a("li",[a("p",[t._v("document.domain 基础域名相同 子域名不同")])]),t._v(" "),a("li",[a("p",[t._v("window.name 利用在一个浏览器窗口内，载入所有的域名都是共享一个window.name")])]),t._v(" "),a("li",[a("p",[t._v("CORS CORS(Cross-origin resource sharing)跨域资源共享 服务器设置对CORS的支持原理：服务器设置Access-Control-Allow-Origin HTTP响应头之后，浏览器将会允许跨域请求")])]),t._v(" "),a("li",[a("p",[t._v("proxy代理 目前常用方式,通过服务器设置代理")])]),t._v(" "),a("li",[a("p",[t._v("window.postMessage() 利用h5新特性window.postMessage()")])])]),t._v(" "),a("p",[a("a",{attrs:{href:"https://juejin.cn/post/7003232769182547998",target:"_blank",rel:"noopener noreferrer"}},[t._v("跨域"),a("OutboundLink")],1)]),t._v(" "),a("h2",{attrs:{id:"_6-cookie、sessionstorage、localstorage-的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6-cookie、sessionstorage、localstorage-的区别"}},[t._v("#")]),t._v(" 6. Cookie、sessionStorage、localStorage 的区别")]),t._v(" "),a("h3",{attrs:{id:"相同点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#相同点"}},[t._v("#")]),t._v(" 相同点：")]),t._v(" "),a("ul",[a("li",[t._v("存储在客户端")])]),t._v(" "),a("h3",{attrs:{id:"不同点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#不同点"}},[t._v("#")]),t._v(" 不同点：")]),t._v(" "),a("ul",[a("li",[t._v("cookie数据大小不能超过4k；sessionStorage和localStorage的存储比cookie大得多，可以达到5M+")]),t._v(" "),a("li",[t._v("cookie设置的过期时间之前一直有效；localStorage永久存储，浏览器关闭后数据不丢失除非主动删除数据；sessionStorage数据在当前浏览器窗口关闭后自动删除")]),t._v(" "),a("li",[t._v("cookie的数据会自动的传递到服务器；sessionStorage和localStorage数据保存在本地")])]),t._v(" "),a("h2",{attrs:{id:"_7-粘包问题分析与对策"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_7-粘包问题分析与对策"}},[t._v("#")]),t._v(" 7. 粘包问题分析与对策")]),t._v(" "),a("p",[t._v("TCP粘包是指发送方发送的若干包数据到接收方接收时粘成一包，从接收缓冲区看，后一包数据的头紧接着前一包数据的尾。")]),t._v(" "),a("h3",{attrs:{id:"_7-1-粘包出现原因"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_7-1-粘包出现原因"}},[t._v("#")]),t._v(" 7.1 粘包出现原因")]),t._v(" "),a("p",[t._v("简单得说，在流传输中出现，UDP不会出现粘包，因为它有消息边界\n粘包情况有两种，一种是粘在一起的包都是完整的数据包，另一种情况是粘在一起的包有不完整的包。\n为了避免粘包现象，可采取以下几种措施：")]),t._v(" "),a("ol",[a("li",[t._v("对于发送方引起的粘包现象，用户可通过编程设置来避免，TCP提供了强制数据立即传送的操作指令push，TCP软件收到该操作指令后，就立即将本段数据发送出去，而不必等待发送缓冲区满；")]),t._v(" "),a("li",[t._v("对于接收方引起的粘包，则可通过优化程序设计、精简接收进程工作量、提高接收进程优先级等措施，使其及时接收数据，从而尽量避免出现粘包现象；")]),t._v(" "),a("li",[t._v("由接收方控制，将一包数据按结构字段，人为控制分多次接收，然后合并，通过这种手段来避免粘包。分包多发。")])]),t._v(" "),a("p",[t._v("以上提到的三种措施，都有其不足之处。")]),t._v(" "),a("ol",[a("li",[t._v("第一种编程设置方法虽然可以避免发送方引起的粘包，但它关闭了优化算法，降低了网络发送效率，影响应用程序的性能，一般不建议使用。")]),t._v(" "),a("li",[t._v("第二种方法只能减少出现粘包的可能性，但并不能完全避免粘包，当发送频率较高时，或由于网络突发可能使某个时间段数据包到达接收方较快，接收方还是有可能来不及接收，从而导致粘包。")]),t._v(" "),a("li",[t._v("第三种方法虽然避免了粘包，但应用程序的效率较低，对实时应用的场合不适合。")])]),t._v(" "),a("h2",{attrs:{id:"_8-从输入url到页面加载的全过程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_8-从输入url到页面加载的全过程"}},[t._v("#")]),t._v(" 8. 从输入URL到页面加载的全过程")]),t._v(" "),a("ol",[a("li",[t._v("首先在浏览器中输入URL")]),t._v(" "),a("li",[t._v("查找缓存：浏览器先查看浏览器缓存-系统缓存-路由缓存中是否有该地址页面，如果有则显示页面内容。如果没有则进行下一步。")])]),t._v(" "),a("ul",[a("li",[t._v("浏览器缓存：浏览器会记录DNS一段时间，因此，只是第一个地方解析DNS请求；")]),t._v(" "),a("li",[t._v("操作系统缓存:如果在浏览器缓存中不包含这个记录，则会使系统调用操作系统， 获取操作系统的记录(保存最近的DNS查询缓存)；")]),t._v(" "),a("li",[t._v("路由器缓存：如果上述两个步骤均不能成功获取DNS记录，继续搜索路由器缓存；")]),t._v(" "),a("li",[t._v("ISP缓存：若上述均失败，继续向ISP搜索。")])]),t._v(" "),a("ol",{attrs:{start:"3"}},[a("li",[t._v("DNS域名解析：浏览器向DNS服务器发起请求，解析该URL中的域名对应的IP地址。DNS服务器是基于UDP的，因此会用到UDP协议。")]),t._v(" "),a("li",[t._v("建立TCP连接：解析出IP地址后，根据IP地址和默认80端口，和服务器建立TCP连接")]),t._v(" "),a("li",[t._v("发起HTTP请求：浏览器发起读取文件的HTTP请求，，该请求报文作为TCP三次握手的第三次数据发送给服务器")]),t._v(" "),a("li",[t._v("服务器响应请求并返回结果：服务器对浏览器请求做出响应，并把对应的html文件发送给浏览器")]),t._v(" "),a("li",[t._v("关闭TCP连接：通过四次挥手释放TCP连接")]),t._v(" "),a("li",[t._v("浏览器渲染：客户端（浏览器）解析HTML内容并渲染出来，浏览器接收到数据包后的解析流程为：")])]),t._v(" "),a("ul",[a("li",[t._v("构建DOM树：词法分析然后解析成DOM树（dom tree），是由dom元素及属性节点组成，树的根是document对象")]),t._v(" "),a("li",[t._v("构建CSS规则树：生成CSS规则树（CSS Rule Tree）")]),t._v(" "),a("li",[t._v("构建render树：Web浏览器将DOM和CSSOM结合，并构建出渲染树（render tree）")]),t._v(" "),a("li",[t._v("布局（Layout）：计算出每个节点在屏幕中的位置")]),t._v(" "),a("li",[t._v("绘制（Painting）：即遍历render树，并使用UI后端层绘制每个节点。")])]),t._v(" "),a("ol",{attrs:{start:"9"}},[a("li",[t._v("JS引擎解析过程：调用JS引擎执行JS代码（JS的解释阶段，预处理阶段，执行阶段生成执行上下文，VO，作用域链、回收机制等等）")])]),t._v(" "),a("ul",[a("li",[t._v("创建window对象：window对象也叫全局执行环境，当页面产生时就被创建，所有的全局变量和函数都属于window的属性和方法，而DOM Tree也会映射在window的doucment对象上。当关闭网页或者关闭浏览器时，全局执行环境会被销毁。")]),t._v(" "),a("li",[t._v("加载文件：完成js引擎分析它的语法与词法是否合法，如果合法进入预编译")]),t._v(" "),a("li",[t._v("预编译：在预编译的过程中，浏览器会寻找全局变量声明，把它作为window的属性加入到window对象中，并给变量赋值为'undefined'；寻找全局函数声明，把它作为window的方法加入到window对象中，并将函数体赋值给他（匿名函数是不参与预编译的，因为它是变量）。而变量提升作为不合理的地方在ES6中已经解决了，函数提升还存在。")]),t._v(" "),a("li",[t._v("解释执行：执行到变量就赋值，如果变量没有被定义，也就没有被预编译直接赋值，在ES5非严格模式下这个变量会成为window的一个属性，也就是成为全局变量。string、int这样的值就是直接把值放在变量的存储空间里，object对象就是把指针指向变量的存储空间。函数执行，就将函数的环境推入一个环境的栈中，执行完成后再弹出，控制权交还给之前的环境。JS作用域其实就是这样的执行流机制实现的。")])]),t._v(" "),a("p",[a("a",{attrs:{href:"https://juejin.cn/post/7005468491067162655",target:"_blank",rel:"noopener noreferrer"}},[t._v("DNS域名解析过程"),a("OutboundLink")],1),t._v(" "),a("a",{attrs:{href:"https://juejin.cn/post/6992597760935460901",target:"_blank",rel:"noopener noreferrer"}},[t._v("浏览器的工作原理"),a("OutboundLink")],1)]),t._v(" "),a("h2",{attrs:{id:"_9-浏览器重绘与重排的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_9-浏览器重绘与重排的区别"}},[t._v("#")]),t._v(" 9. 浏览器重绘与重排的区别？")]),t._v(" "),a("ul",[a("li",[t._v("重排/回流（Reflow）：当DOM的变化影响了元素的几何信息，浏览器需要重新计算元素的几何属性，将其安放在界面中的正确位置，这个过程叫做重排。表现为重新生成布局，重新排列元素。")]),t._v(" "),a("li",[t._v("重绘(Repaint): 当一个元素的外观发生改变，但没有改变布局,重新把元素外观绘制出来的过程，叫做重绘。表现为某些元素的外观被改变")])]),t._v(" "),a("p",[t._v("单单改变元素的外观，肯定不会引起网页重新生成布局，但当浏览器完成重排之后，将会重新绘制受到此次重排影响的部分")]),t._v(" "),a("p",[t._v("重排和重绘代价是高昂的，它们会破坏用户体验，并且让UI展示非常迟缓，而相比之下重排的性能影响更大，在两者无法避免的情况下，一般我们宁可选择代价更小的重绘。")]),t._v(" "),a("p",[t._v("『重绘』不一定会出现『重排』，『重排』必然会出现『重绘』。")])])}),[],!1,null,null,null);s.default=v.exports}}]);